Для диплома

Первая глава = НИР.

Вторая глава

Что такое инструмент
Что такое производительность - определение
О языках описать и о node js пара страниц
Как считается производительность и отделньо для данного проекта
Описать среду (где я делаю, ОС либы схемки расписать процесс что к чему обращается)
Описать функции, ссылка на гитхаб
Замерить производительность нескольких функций

Пока писать свободно, потом страницы сожмем разожмем


Заключение

мы получили средний выйгрыш такой то



Алгоритмы

Генетические алгоритмы




Каждое слово допрашивать будут


Сформулировать определение производительности, потом выберем алгоритмы




С вычислением числа Пи сработало. с модулем в два раза быстрее

```bash
ilya-guseynov@ig-ubuntu:~/Developer/nan/examples/async_pi_estimate$ node addon.js
Cpp method:
        π ≈ 3.141582892 (0.000009761589792933734 away from actual)
        Took 6256ms

Js method:
        π ≈ 3.141548064 (0.00004458958979292049 away from actual)
        Took 14517ms

```










1. Нашел в инете

https://habr.com/ru/post/129346/

Понятие производительности с точки зрения ПО означает либо продуктивность, либо реактивность:
продуктивность – объем информации, обрабатываемой системой в единицу времени;
реактивность – время между предъявлением системе входных данных и появлением соответствующей выходной информации.
В данной работе в качестве меры производительности ПО будет рассматриваться именно реактивность.

http://codenet.ru/webmast/php/perfomance/



Здравствуйте!

Вообщем я потестировал некоторые функции и поискал на счет определения производительности.
Есть некоторые проблемы. Оказывается сама платформа тоже очень шустрая.
Единственная функция где плюсы оказалиь быстрее это алгоритм фибоначи.
Такие функции как сумма матриц, вычисление простое ли число и банальная сумма элементов вектора быстрее на чистой node.js иногда раз в 20.

Не могли бы подсказать какие алгоритмы можно подобрать?

Или можно вместо общих алгоритмов подобрать какие то определенные задачи (Пройтись по пикселям картинки и что то сдалать, pathfinder, или еще чтото) и для них написать реализацию на c++.

Также поискал какое определение можно использовать для производительности. Нашел такое.
Производительность - это время между предъявлением системе входных данных и появлением соответствующей выходной информации.
Ну то есть буквальная привязка понятия производительности к времени исполнения.


Ссылка на репозиторий. https://github.com/ilya-guseynov/computing-node
Там указал инструкцию как протестировать на ubuntu



Добрый день. Удалось посмотреть?

Я решил попробовать некоторые изменения на примере суммирования матриц:
Было:
sumMatrix:
--Проверить аргументы из JS, если что выкинуть ошибку
--Проверить матрицу, если что выкинуть ошибку (Первый проход по всей матрице чтобы проверить)
--Перевести в векторы из v8::Array (Второй проход по всей матрице чтобы перевести в вектор)
--{Сумма матриц через векторы, тут можно было изменять код для разных алгоритмов}
--Перевести в v8::Array из векторов (Второй проход по всей матрице чтобы перевести в v8::Array)
--Вернуть новую матрицу в JS

Стало
sumMatrix:
--Проверить аргументы, если что выкинуть ошибку
--Начать проход по матрице
----Проверять на ходу, если что выкинуть ошибку
----Считать не преобразуя в вектор
--Вернуть новую матрицу в JS

Хоть я и полукчил выйгрыш в два раза
До
```
sumMatrix(1000) Node.js is faster ~200ms
```
После
```
sumMatrix(1000) Node.js is faster ~100ms
```

Вот к какому выводу я пришел

В модулях очень много проверок чтобы алгоритм не ломался.
И эти проверки
1) Обязательны
2) Как оказалось, дорогие по времени

Нужно постоянно проверять Что каждый элемент и вправду существует и поменять тип
```
if !maybe_value.IsEmpty()
  v8::MaybeLocal<v8::Value> maybe_value => v8::Local<v8::Value> value
```
И нужно проверять тип переменной JS чтобы его точно определить и поменять тип
```
if !value.IsNumber()
  v8::Local<v8::Value> value => v8::Local<v8::Number> number
```

И таких проверок в обходе матрицы очень много.

По этому мне кажется Алгоритм фибоначчи и оказался быстрее, только потому что, на вход подается только одно число. И проверок никаких нет.
По этому мне кажется стоит подобрать алгоритмы где хоть и нет больших данных на вход, но все рано есть сложные и большие вычисления.

